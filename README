ABOUT
This module aims to provide an easy to use interface to Devel::Declare. 

If you haven't heard of DD, you have probably been sitting under a rock for the few months, I suggest you take a look at the following modules:

Devel::Develare
http://search.cpan.org/~flora/Devel-Declare-0.005011/lib/Devel/Declare.pm

MooseX::Declare
http://search.cpan.org/~flora/MooseX-Declare-0.32/lib/MooseX/Declare.pm

I really don't know what I am doing, so all feedback / abuse is welcome

TODO
* write more tests, docs and examples
* cleanup parser construction (check if code exists etc)
* write default action to return whatever the parse routine matched

SYNTAX
#parse an action routines called for each entry in proto
keyword method (ident?, proto?, custom, block) {
	$block->end($proto->{end_code});
	$block->begin($proto->{begin_code});
	$block->name($ident);
}

#passed a Keyword::Parser object
parse custom ($parser) {
	if (my $len = $parser->scan_word(1)) {
		my $l = $parser->line;
		my $ident = substr($l, $parser->offset, $len);
		substr($l, $parser->offset, $len) = '';
		$parser->line($l);
		return $ident if $ident =~ /^[a-z]{1}\w+$/i;
	}
	else {
		die "unable to match blah";
	}
}

#passed whatever the parse routine matches
action proto ($match) {
	my $match;
	return $code;
}

YADDA
<mst> rob: hey, we were talking about this
<mst> basically, the answer is to standardise the declaration forms
<mst> so you have something like
<mst> keyword method (Proto?, Name?, Block) {
<mst> and then that can we statically analyzed by something like PPI
<mst> in order to work out what the syntax is for the keyword
<mst> then anything using 'keyword' can be supported by a single set of code
<kentnl> I think you'd first have to standardise the syntax for declaring declarations
<kentnl> but yes, I see what you mean :)
<Zefram> a structured macro facility would help there.  but we're some way off being able to do that
<mst> kentnl: yes
<mst> kentnl: that's the point
<mst> kentnl: we write a Devel::Declare keyword -called- keyword
<mst> and standardise on that
<Zefram> we desperately need APIs for things like "parse a block" (properly)
<mst> yes. I was hoping we vcould at least work out how to fake them in the process
<Zefram> I have a long-term plan to let much of the Perl parser work in a recursive-descent manner
<kentnl> also, for pedanticsness sake, wouldn't the signature be keyword method ( Name?, Proto?, Block ) , unless of course, you meant the example to do "method ( $foo, $bar, $baz ) mymethod  { } " notation
