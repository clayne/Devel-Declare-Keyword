ABOUT
This module aims to provide an easy interface to Devel::Declare. 

I suggest you take a look at these first:

Devel::Declare
http://search.cpan.org/~flora/Devel-Declare-0.005011/lib/Devel/Declare.pm

MooseX::Declare
http://search.cpan.org/~flora/MooseX-Declare-0.32/lib/MooseX/Declare.pm

I really don't know what I am doing, so all feedback / abuse is welcome.

robin dot ge at gmail dot com

TODO
* remove globals
* add support for blockless keywords
* add eos inject see MXD
* cleanup parser construction (check if code exists etc)
* write default action to return whatever the parse routine matched

PLAN
* alter Keyword::Declare to sub class of DD:C:S?
* create new Keyword::Parser class for storing parse routines

SYNTAX
#parse an action routines called for each entry in proto
keyword method (ident?, proto?, custom, block) {
	$block->name($ident); # name the block
	$block->inject_begin($proto); # inject at begin of block
	$block->inject_after("warn '$ident() finished';");
	$block->terminate; # add semi colon
}

#passed a Keyword::Declare object
parse custom ($parser) {
	if (my $len = $parser->scan_word(1)) {
		my $l = $parser->line;
		my $ident = substr($l, $parser->offset, $len);
		substr($l, $parser->offset, $len) = '';
		$parser->line($l);
		return $ident if $ident =~ /^[a-z]{1}\w+$/i;
	}
	else {
		die "unable to match blah";
	}
}

#passed whatever the parse routine matches
action proto ($match) {
	my $match;
	return $code;
}

IRC
<mst> rob: hey, we were talking about this
<mst> basically, the answer is to standardise the declaration forms
<mst> so you have something like
<mst> keyword method (Proto?, Name?, Block) {
<mst> and then that can we statically analyzed by something like PPI
<mst> in order to work out what the syntax is for the keyword
<mst> then anything using 'keyword' can be supported by a single set of code
<kentnl> I think you'd first have to standardise the syntax for declaring declarations
<kentnl> but yes, I see what you mean :)
<Zefram> a structured macro facility would help there.  but we're some way off being able to do that
<mst> kentnl: yes
<mst> kentnl: that's the point
<mst> kentnl: we write a Devel::Declare keyword -called- keyword
<mst> and standardise on that
<Zefram> we desperately need APIs for things like "parse a block" (properly)
<mst> yes. I was hoping we vcould at least work out how to fake them in the process
<Zefram> I have a long-term plan to let much of the Perl parser work in a recursive-descent manner
<kentnl> also, for pedanticsness sake, wouldn't the signature be keyword method ( Name?, Proto?, Block ) , unless of course, you meant the example to do "method ( $foo, $bar, $baz ) mymethod  { } " notation

...

<pdcawley> Same technique as is used to insert the semicolon in Moose::Declare is a good starting point.
<pdcawley> Yeah, injecting into the backend of the block is, currently, a no no.
<rob> yea but by that point its compiled the block, so I can't seem to inject code there
<rob> until we can parse a block
<pdcawley> But you can inject something into the beginning which sets up a datastructure that your end of scope stuff can make use of.
<pdcawley> Obviously, you need to do something before the block which _declares_ the thing that your 'after' stuff can see
<rob> yea
<rob> may run into issues if a keyword like method is used for anon sub though?
<pdcawley> And you can always insert 'setup_shit; $ret = do {<$block_contents' and have an EOS like '; do_shit; return $ret}'
<pdcawley> MXD's EOS stuff catches that as well, I think.
<rob> ok
<pdcawley> Basically, at the point you set up the insertions, you know if you have a name or are anonymous, so you know whether you need to insert a semicolon at the end or not.

#mk_parser() 
<pdcawley> Just build a method based on $ident and dispatch to that.
<rob> ok
<pdcawley> I'd suggest making an object as early as possible, your dispatch issues get so much easier then.
